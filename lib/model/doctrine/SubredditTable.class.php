<?php

/**
 * SubredditTable
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class SubredditTable extends Doctrine_Table
{

    /**
     * Returns an instance of this class.
     *
     * @return object SubredditTable
     */
    public static function getInstance()
    {
        return Doctrine_Core::getTable('Subreddit');
    }

    /**
     * Pulls the 'subreddit_id' from a given sub-array.
     *
     * @param array $value  The sub-array from which to take the subreddit_id.
     * @return int          The subreddit_id contained in the sub-array.
     */
    public static function grabSubredditIdFromArray($value)
    {
        return (is_array($value) ? $value['subreddit_id'] : null);
    }

    /**
     * Check for all Subreddits that have an Episode with a release_date
     * beyond now plus the creation_interval.
     * 
     * This means that only when the release_dates all fall within the
     * creation_interval will the Subreddit not be returned.  
     *
     * @return array   Array of Subreddits that don't need generation
     */
    public function getSubredditsNotNeedingEpisodeGeneration()
    {
        $subquery = $this->createQuery()
                ->select('Episode.subreddit_id')
                ->from('Episode')
                ->leftJoin('Episode.Subreddit Subreddit')
                ->groupBy('Episode.subreddit_id')
                ->where('UNIX_TIMESTAMP(Episode.release_date) > (Subreddit.creation_interval + UNIX_TIMESTAMP())');
        $subquery = $subquery
                ->fetchArray();
        $ids = array_map(array('SubredditTable', 'grabSubredditIdFromArray'),
                         $subquery);
        return $ids;
    }

    /**
     * Retrieves all Subreddits that are in need of generating new Episodes.
     * Checking against particular Subreddits can be done by giving the
     * Subreddit name as an argument (accepts SQL LIKE format).
     *
     * @param string $subreddit_name A given Subreddit name to check against.
     * @return array                 An array of Subreddits
     */
    public function getSubredditsNeedingEpisodeGeneration($subreddit_name = '%')
    {
        $ids = $this->getSubredditsNotNeedingEpisodeGeneration();
        $subreddits = $this->createQuery()
                ->where('Subreddit.name LIKE ?', $subreddit_name)
                ->whereNotIn('Subreddit.id', $ids)
                ->execute();

        return $subreddits;
    }

    /**
     * Retrieves the release date for the youngest Episode of the given 
     * Subreddit.
     *
     * @param int $subreddit_id  The incremented ID of a Subreddit object
     * @return string            The release date of the youngest Episode.
     */
    public function getLastEpisodeReleaseDate($subreddit_id)
    {
        $results = $this->createQuery()
                ->select('Episode.release_date')
                ->from('Episode')
                ->where('Episode.subreddit_id = ?', $subreddit_id)
                ->orderBy('Episode.release_date DESC')
                ->limit(1)
                ->fetchArray();
        return (count($results) ? strtotime($results[0]['release_date']) : time());
    }
    
    public function advanceEpisodeAssignments()
    {   
        $subreddit_first_deadlines = array();
        $subreddit_deadline_rules = array();

        // We establish the pool of emails we'll be sending.
        // First to those who pass their deadline
        $passed_deadline_assignments = array();

        // And to the new episode assignments that are reassigned
        $newly_assigned_assignments = array();

        // Now we can start on the assignments that are misassigned
        $assignments = EpisodeAssignmentTable::getInstance()->getMisassignedEpisodes();
        $episodes = new Doctrine_Collection('Episode');
        $e = -1;
        for($i = 0; $i < count($assignments); $i++)
        {
            $passed_deadline_assignments[] = $assignments[$i];
            $assignments[$i]->setMissedDeadline(true);
            $episodes[++$e] = $assignments[$i]->getEpisode();
            // Clean up the Episode for any new user to use.
            $episodes[$e]->setEpisodeAssignmentId(null);
            $audio_file = $episodes[$e]->getAudioFile();
            $nice_filename = $episodes[$e]->getNiceFilename();
            $graphic_file = $episodes[$e]->getGraphicFile();
            $episodes[$e]->setAudioFile(null);
            $episodes[$e]->setNiceFilename(null);
            $episodes[$e]->setGraphicFile(null);
            $episodes[$e]->setIsNsfw(false);
            $episodes[$e]->setTitle(null);
            $episodes[$e]->setDescription(null);
            $episodes[$e]->setIsSubmitted(false);
            $episodes[$e]->setSubmittedAt(null);
            $episodes[$e]->setFileIsRemote(null);
            $episodes[$e]->setRemoteUrl(null);
            $episodes[$e]->setRedditPostUrl(null);
        }
        $episodes->save();
        $assignments->save();
        
        /* Now we make sure that all assignments past deadline are marked as
         * such.  If the assignment is here, however, then it hasn't ever
         * actually BEEN assigned and isn't added to the list of emails to send
         * out. */
        $assignments = EpisodeAssignmentTable::getInstance()->getUnmarkedEpisodesThatMissedDeadlines();
        for($i = 0; $i < count($assignments); $i++)
        {
            $assignments[$i]->setMissedDeadline(true);
        }
        $assignments->save();

        /* Now all episodes are cleared and we need to see if they need to be
         * reassigned to an existing asignment. */

        /* Returns assignments closest to the front for each unassigned episode,
         * in order of closeness. */
        $assignments = EpisodeAssignmentTable::getInstance()->getEpisodesPossiblyNeedingAssignment();
        $subreddit_ids = EpisodeAssignmentTable::getInstance()->getSubrbedditsOfEpisodesPossiblyNeedingAssignment();
        $deadlines = DeadlineTable::getInstance()->getDeadlinesForGivenSubreddits($subreddit_ids);
        $subreddit_first_authortypes = array();
        $subreddit_deadline_rules = array();
        $begun = false;
        $prev_subreddit_id = null;
        foreach($deadlines as $deadline)
        {
            $subreddit_id = $deadline['subreddit_id'];
            if ($prev_subreddit_id != $subreddit_id && $begun)
            {
                $begun = false;
                $prev_subreddit_id = $subreddit_id;
            }
            if (!$begun)
            {
                $subreddit_deadline_rules[$subreddit_id] = array(
                    $deadline['author_type_id'] => $deadline['seconds'],
                );
                $subreddit_first_authortypes[$subreddit_id] = $deadline['author_type_id'];
                $begun = true;
            } else {
                $author_type_id = $deadline['author_type_id'];
                $subreddit_deadline_rules[$subreddit_id][$author_type_id] = $deadline['seconds'];
            }
        }
        
        $episodes_affected = array();

        // Things used from assignment: episode_id, epsiode, author_type_id, id, sf_guard_user_id
        // Things used from episode: subreddit_id, surbeddit, release_date, 
        // Things used from subreddit: getFirstDeadlineId(), getDeadlineRules()
        foreach ($assignments as $assignment) {
            if (!in_array($assignment['episode_id'], $episodes_affected)) {
                /* Ignore all subsequent assignments for an episode after the
                 * first!  We should only be dealing with assignments that have
                 * not missed their deadlines! */
                $episodes_affected[] = $assignment['episode_id'];
                $assign_to_episode = false;
                $subreddit_id = $assignment['subreddit_id'];
                $subreddit = SubredditTable::getInstance()->find($subreddit_id);

                /* If the *first* assignment is in the first spot, then assign
                 * it. */                
                $deadline_rules = $subreddit_deadline_rules[$subreddit_id];
                
                $author_type_id = $assignment['author_type_id'];
                
                if ($author_type_id == $subreddit_first_authortypes[$subreddit_id]) {
                    $assign_to_episode = true;
                } else {
                    /* Otherwise, check if we are past the deadline for the
                     * previous deadline. */
                    
                    /*$previous_author_type_id = DeadlineTable::getInstance()
                            ->getFirstAuthorTypeIdBySubredditWhereDeadlineIsGreaterThan(
                            $deadline_rules[$author_type_id],
                            $subreddit_id);*/
                    $inverse_deadline_rules = array_reverse($deadline_rules, true);
                    $previous_author_type_id = null;
                    foreach($inverse_deadline_rules as $author_type => $seconds)
                    {
                        if ($seconds > $deadline_rules[$author_type_id]) {
                            $previous_author_type_id = $author_type;
                            break;
                        }
                    }
                    $past_deadline_for_previous = strtotime($assignment['release_date']) - $deadline_rules[$previous_author_type_id] <= time();
                    if ($past_deadline_for_previous) {
                        $assign_to_episode = true;
                    }
                }
                if ($assign_to_episode) {
                    $saved_episode = EpisodeTable::getInstance()->find($assignment['episode_id']);
                    $saved_episode->setEpisodeAssignmentId($assignment['id']);
                    $saved_episode->save();
                    $newly_assigned_assignments[] = $assignment;
                }
            }
        }

        // We send the emails for the current deadline we're checking.
        foreach ($passed_deadline_assignments as $assignment) {
            $this->sendEmailAboutPassedDeadline($assignment['sf_guard_user_id'],
                                                $assignment['episode_id']);
        }

        foreach ($newly_assigned_assignments as $assignment) {
            $release_date = strtotime($assignment['release_date']);
            $author_type_id = $assignment['author_type_id'];
            $seconds = $deadline_rules[$author_type_id];
            $deadline = $release_date - $seconds;
            $this->sendEmailAboutNewAssignment($assignment['sf_guard_user_id'],
                                               $assignment['episode_id'],
                                               $deadline);
        }
    }
    
    public function sendEmailAboutNewAssignment($user_id, $episode_id, $deadline)
    {
        // Send an email to that user telling them their EpisodeAssignment is now valid
        $parameters = array(
            'user_id' => $user_id,
            'episode_id' => $episode_id,
            'deadline' => date('Y-m-d H:i:s', $deadline),
        );
        $user = sfGuardUserTable::getInstance()->find($user_id);

        $prefer_html = $user->getPreferHtml();
        $address = $user->getEmailAddress();
        $name = ($user->getPreferredName() ?
                        $user->getPreferredName() : $user->getFullName());

        $email = EmailTable::getInstance()->getFirstByEmailTypeAndLanguage('NewlyOpenedEpisode',
                                                                           $user->getPreferredLanguage());

        $subject = $email->generateSubject($parameters);
        $body = $email->generateBodyText($parameters, $prefer_html);

        $from = sfConfig::get('app_email_address',
                                     ProjectConfiguration::getApplicationEmailAddress());
        
        AppMail::sendMail($address, $from, $subject, $body, $prefer_html ? $body : null);

        $user->addLoginMessage('You have an episode that you can work with!');
    }

    public function sendEmailAboutPassedDeadline($user_id, $episode_id)
    {
        // Send an email to that user telling them their EpisodeAssignment is now valid
        $parameters = array(
            'user_id' => $user_id,
            'episode_id' => $episode_id
        );
        $user = sfGuardUserTable::getInstance()->find($user_id);

        $prefer_html = $user->getPreferHtml();
        $address = $user->getEmailAddress();
        $name = ($user->getPreferredName() ?
                        $user->getPreferredName() : $user->getFullName());

        $email = EmailTable::getInstance()->getFirstByEmailTypeAndLanguage('PassedDeadlineOnEpisode',
                                                                           $user->getPreferredLanguage());

        $subject = $email->generateSubject($parameters);
        $body = $email->generateBodyText($parameters, $prefer_html);

        $from = sfConfig::get('app_email_address',
                                     ProjectConfiguration::getApplicationEmailAddress());
        
        AppMail::sendMail($address, $from, $subject, $body, $prefer_html ? $body : null);
        
        $user->addLoginMessage('Your episode passed its release deadline and has been re-assigned.');
    }

}