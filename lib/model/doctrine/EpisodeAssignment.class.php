<?php

/**
 * EpisodeAssignment
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    OpenMicNight
 * @subpackage model
 * @author     Tom Doggett
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class EpisodeAssignment extends BaseEpisodeAssignment
{

    public function save(Doctrine_Connection $conn = null)
    {

        if ($this->isNew()) {
            /* Blocked users should not be able to sign up for an Episode.
             */
            if ($this->hasBlockedUser()) {
                $this->deleteWithException("Cannot create EpisodeAssignment "
                        . "because sfGuardUser " . $this->getSfGuardUserId()
                        . " has a blocked Membership within Subreddit "
                        . $this->getEpisode()->getSubredditId());
                return;
            }

            /* Only one sfGuardUser can sign up for one Episode with the same
             * AuthorType for each Application period.
             */
            if ($this->hasExistingUserAuthorTypeAssignment()) {
                $this->deleteWithException("Cannot create EpisodeAssignment "
                        . "because sfGuardUser " . $this->getSfGuardUserId()
                        . " has already registered with AuthorType "
                        . $this->getAuthorTypeId() . " within Subreddit "
                        . $this->getEpisode()->getSubredditId());
                return;
            }

            /* The EpisodeAssignment must be within the deadline for the
             * AuthorType.
             */
            if ($this->isWithinDeadlineForAuthorType()) {
                $this->deleteWithException("Cannot create EpisodeAssignment "
                        . "because the deadline has already passed for "
                        . "AuthorType " . $this->getAuthorTypeId() . " within "
                        . "Subreddit " . $this->getEpisode()->getSubredditId());
                return;
            }

            /* Even if the deadline has not yet passed, we may only sign up an 
             * AuthorType if the AuthorType is allowed to register before the 
             * previous AuthorType (meaning the AuthorType with the next-longest
             * deadline).
             */
            /*
            $user_id = $this->getSfGuardUser();
            $subreddit_id = $this->getEpisode()->getSubreddit();
            $authortype_id = $this->getAuthorType();
            $deadline_seconds = Doctrine::getTable('Deadline')
                    ->getSecondsByAuthorAndSubreddit(
                    $this->getAuthorTypeId(),
                    $this->getEpisode()->getSubredditId()
            );

            $previous_author_type_id = Doctrine_Query::create()
                    ->select('Deadline.author_type_id')
                    ->from('Deadline')
                    ->where('Deadline.subreddit_id = ?', $subreddit_id)
                    ->andWhere('Deadline.seconds > ?', $deadline_seconds)
                    ->orderBy('Deadline.seconds ASC')
                    ->execute()
                    ->getFirst();
            if ($previous_author_type_id) {
                $application_restricted = Doctrine_Query::create()
                        ->select('Application.restricted_until_previous_misses_deadline')
                        ->from('Application')
                        ->where('Application.author_type_id = ?', $authortype_id)
                        ->andWhere('Application.subreddit_id = ?', $subreddit_id)
                        ->execute()
                        ->getFirst();
                if ($application_restricted) {
                    $deadline_seconds = Doctrine_Query::create()
                            ->select('Deadline.seconds')
                            ->from('Deadline')
                            ->where('Deadline.author_type_id = ?',
                                    $previous_author_type_id)
                            ->andWhere('Deadline.subreddit_id = ?',
                                       $subreddit_id)
                            ->execute()
                            ->getFirst();
                    $episode_valid = Doctrine_Query::create()
                            ->select('Episode.id')
                            ->from('Episode')
                            ->where('Episode.id = ?', $this->getEpisodeId())
                            ->andWhere('TO_SECONDS(Episode.release_date - NOW()) > ?',
                                       $deadline_seconds)
                            ->execute()
                            ->getFirst();
                    if ($episode_valid) {
                        $this->delete();
                        throw new sfException("Cannot create EpisodeAssignment because "
                                . "the deadline has not yet passed for the "
                                . "previous AuthorType $authortype_id within "
                                . "Subreddit $subreddit_id.");
                        return;
                    }
                }
            }*/
        }

        parent::save($conn);
    }

    public function hasBlockedUser()
    {
        $membership = Doctrine::getTable('sfGuardUserSubredditMembership')
                ->getFirstByUserSubredditAndMemberships(
                $this->getSfGuardUserId(),
                $this->getEpisode()->getSubredditId(), array('blocked')
        );
        return ($membership ? true : false);
    }

    public function hasExistingUserAuthorTypeAssignment()
    {
        $assignment = Doctrine::getTable('EpisodeAssignment')
                ->getFirstByUserAuthorTypeAndSubreddit(
                $this->getAuthorTypeId(), $this->getSfGuardUserId(),
                $this->getEpisode()->getSubredditId()
        );
        return ($assignment ? true : false);
    }

    public function isWithinDeadlineForAuthorType()
    {
        $deadline_seconds = Doctrine::getTable('Deadline')
                ->getSecondsByAuthorAndSubreddit(
                $this->getAuthorTypeId(), $this->getEpisode()->getSubredditId()
        );
        $release_date = new DateTime($this->getEpisode()->getReleaseDate());
        $now = new DateTime(date('Y-m-d H:i:s', time()));
        $diff = $release_date->diff($now, true);
        $seconds_between = ($diff->y * 365 * 24 * 60 * 60) +
                ($diff->m * 30 * 24 * 60 * 60) +
                ($diff->d * 24 * 60 * 60) +
                ($diff->h * 60 * 60) +
                $diff->s;
        return ($deadline_seconds > $seconds_between );
    }

    public function deleteWithException($message = null, $code = null,
                                        $previous = null)
    {
        $this->delete();
        throw new sfException($message, $code, $previous);
    }

}
