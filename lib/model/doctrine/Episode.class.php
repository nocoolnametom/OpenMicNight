<?php

/**
 * Episode
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    OpenMicNight
 * @subpackage model
 * @author     Tom Doggett
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class Episode extends BaseEpisode
{

    /**
     * Returns the Episode title
     *
     * @return string  The object formatted as a string
     */
    public function __toString()
    {
        return $this->getTitle();
    }

    public function setSfGuardUserId($user_id)
    {
        $user_found = false;
        // Verify that the user exists in an EpisodeAssignment
        foreach ($this->getEpisodeAssignments() as $assignment) {
            /* @var $assignment EpisodeAssignment */
            $episode_user_id = $assignment->getSfGuardUserId();
            if ($episode_user_id == $user_id) {
                $user_found = true;
                break;
            }
        }
        if (!$user_found && !is_null($user_id))
            return;

        // We found a user - are they within their Deadline?
        if ($user_found) {
            /* If they're not within their Deadline we cannot save them to the
             * Episode.
             */
            if (!$assignment->isBeforeDeadlineForAuthorType()) {
                return;
            }
        }

        $this->_set('sf_guard_user_id', $episode_user_id);
    }

    public function setIsSubmitted($is_submitted)
    {
        // Episode Must already have a User
        if (!$this->getSfGuardUser())
            return;
        
        // Episode must also have a file attached
        if (!$this->getAudioFile())
            return;

        // The User who is submitting must be within their Deadline.
        $assignment = EpisodeAssignmentTable::getInstance()
                ->getFirstByUserEpisodeAndSubreddit(
                $this->getSfGuardUserId(), $this->getIncremented(),
                $this->getSubredditId());
        if (!$assignment || !$assignment->isBeforeDeadlineForAuthorType()) {
            return;
        }

        // We set the timestamp for this action.
        if ($is_submitted)
            $this->setSubmittedAt(date('Y-m-d H:i:s'));

        if ($this->getIsSubmitted())
            return;

        $this->_set('is_submitted', $is_submitted);
    }

    public function setApprovedBy($approver_id)
    {
        // Episode must already have a User
        if (!$this->getSfGuardUserId() || !$this->getIsSubmitted())
            return;

        if ($this->getSfGuardUserId() == $approver_id)
            return;

        // The Approver must actually *be* an approver in the Episode Subreddit.
        $membership = sfGuardUserSubredditMembershipTable::getInstance()
                ->getFirstByUserSubredditAndMemberships(
                $approver_id, $this->getSubredditId(),
                array('moderator', 'admin')
        );
        if (!$membership)
            return;

        $this->_set('approved_by', $approver_id);
    }
    
    public function getNiceFilename()
    {
        $nice_filename = $this->_get('nice_filename');
        $nice_filename = ($nice_filename ? $nice_filename : $this->getAudioFile());
        $nice_filename = preg_replace("/[^a-zA-Z0-9\-:\(\)\.]/", "_", $nice_filename);
        return $nice_filename;
    }

    public function setIsApproved($is_approved, $file_location = '')
    {
        // Episode must already have a User
        if (!$this->getSfGuardUser())
            return;

        // Episode must already have an Approver set beforehand
        if (!$this->getApprovedBy())
            return;

        // The Episode cannot be approved by its User
        if ($this->getSfGuardUserId() == $this->getApprovedBy())
            return;

        // The Approver must actually *be* an approver in the Episode Subreddit.
        $membership = sfGuardUserSubredditMembershipTable::getInstance()
                ->getFirstByUserSubredditAndMemberships(
                $this->getApprovedBy(), $this->getSubredditId(),
                array('moderator', 'admin')
        );
        if (!$membership)
            return;

        // We set the timestamp for this action.
        if ($is_approved)
            $this->setApprovedAt(date('Y-m-d H:i:s'));
        
        $now = new DateTime();
        $release_date = new DateTime($this->getReleaseDate());

        if ($is_approved && !$this->_get('is_approved')) {
            // We move the physical file of the Episode to Amazon.
            if ($file_location)
                $this->moveEpisodeFileToAmazon($file_location);
        } elseif (!$is_approved && $this->_get('is_approved') && ($now < $release_date)) {
            // We move the physical file of the Episode from Amazon.
            if ($file_location)
                $this->moveEpisodeFileFromAmazon($file_location);
        }

        $this->_set('is_approved', $is_approved);
    }

    public function moveEpisodeFileToAmazon($file_location)
    {
        if (!$this->getAudioFile())
            throw new Exception("No local file to upload!");
        $filename = $file_location . $this->getAudioFile();
        if (!file_exists($filename))
            throw new Exception("No local file to upload!");
        ProjectConfiguration::registerAws();
        $s3 = new AmazonS3;
        $bucket = $this->getSubreddit()->getBucketName();
        if ($s3->if_bucket_exists($bucket)) {
            $response = $s3->create_object($bucket, $this->getNiceFilename(),
                                          array(
                'fileUpload' => $file_location . $this->getAudioFile()
                    ));
            if ($response->isOK())
                $this->setRemoteUrl($s3->get_object_url($bucket,
                                                        $this->getNiceFilename()));
        } else {
            throw new Exception("Amazon bucket '$bucket' does not exist!");
        }
        $this->setFileIsRemote(true);
    }

    public function moveEpisodeFileFromAmazon($file_location)
    {
        ProjectConfiguration::registerAws();
        $s3 = new AmazonS3;
        $bucket = $this->getSubreddit()->getBucketName();
        if (!$s3->if_bucket_exists($bucket)) {
            throw new Exception("Amazon bucket '$bucket' does not exist!");
        }
        $response = $s3->get_object($bucket, $this->getNiceFilename(),
                                    array(
            'fileDownload' => $file_location . $this->getAudioFile()
                ));
        if (!$response->isOK())
            throw new Exception('There was an error retrieving from Amazon.');
        $this->deleteEpisodeFileFromAmazon();
        $this->setFileIsRemote(false);
    }

    public function deleteLocalFile($filename, $file_location = '')
    {
        if (!file_exists($filename)) {
            throw new Exception("$filename does not exist in $file_location");
        }
        if (!unlink($file_location . $filename)) {
            throw new Exception("Failed to remove $file_location$filename...\n");
        }
    }

    public function deleteEpisodeFileFromAmazon($filename = null, $bucket = null)
    {
        ProjectConfiguration::registerAws();
        $s3 = new AmazonS3;
        $bucket = (is_null($bucket) ? $this->getSubreddit()->getBucketName() : $bucket);
        if (!$s3->if_bucket_exists($bucket)) {
            throw new Exception("Amazon bucket '$bucket' does not exist!");
        }
        $filename = (is_null($filename) ? $this->getNiceFilename() : $filename);
        $response = $s3->delete_object($bucket, $filename);
        if (!$response->isOK())
            throw new Exception('Failed to remove file from Amazon!');
    }

    public function getEpisodeAssignments()
    {
        return EpisodeAssignmentTable::getInstance()->getAllByEpisodeId($this->getIncremented());
    }

    public function getIsSubmitted()
    {
        return (bool) $this->_get('is_submitted');
    }

    public function getIsApproved()
    {
        return (bool) $this->_get('is_approved');
    }

}
