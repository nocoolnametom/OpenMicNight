<?php

/**
 * Subreddit
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    OpenMicNight
 * @subpackage model
 * @author     Tom Doggett
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class Subreddit extends BaseSubreddit
{
    
    /**
     * Returns the Subreddit name
     *
     * @return string  The object formatted as a string
     */
    public function __toString()
    {
        return $this->getName();
    }

    public function setName($name)
    {
        $this->_set('name', $name);
        if ($this->getName() && (!$this->getBucketName() || strlen($this->getBucketName()) == 0)) {
            $bucket_name = $this->createAmazonBucketName('herddit-' . $name);
            $this->setBucketName($bucket_name);
        }
    }

    public function createAmazonBucketName($name)
    {
        ProjectConfiguration::registerAws();
        $aws = new AmazonS3();
        if (!$aws->if_bucket_exists($name)) {
            $aws->create_bucket($name, AmazonS3::REGION_US_E1,
                                AmazonS3::ACL_PUBLIC);
            $exists = $aws->if_bucket_exists($name);
            while (!$exists) {
                // Not yet? Sleep for 1 second, then check again
                sleep(1);
                $exists = $aws->if_bucket_exists($name);
            }
            return $name;
        }
        $response = $aws->get_bucket_policy($name);
        if (in_array($response->status, array(403, 405)))
            return $this->createAmazonBucketName($name . rand(0, 1000));
    }

    public function deleteAmazonBucket($name)
    {
        ProjectConfiguration::registerAws();
        $aws = new AmazonS3();
        if ($aws->if_bucket_exists($name)) {
            return $aws->delete_bucket($name);
        }
    }

    public function delete(Doctrine_Connection $conn = null)
    {
        $bucket_name = $this->getBucketName();
        parent::delete($conn);
        $this->deleteAmazonBucket($bucket_name);
    }

    /**
     * Returns the Episode schedule as a CronExpression.
     * 
     * @see Cron\CronExpression::factory
     *
     * @return Cron\CronExpression The Episode schedule
     */
    public function getEpisodeScheduleAsCronExpression()
    {
        ProjectConfiguration::registerCron();
        return Cron\CronExpression::factory(parent::getEpisodeScheduleCronFormatted());
    }

    /**
     * Returns the creation schedule as a CronExpression.
     * 
     * @see Cron\CronExpression::factory
     *
     * @return Cron\CronExpression The creation schedule
     */
    public function getCreationScheduleAsCronExpression()
    {
        ProjectConfiguration::registerCron();
        return Cron\CronExpression::factory(parent::getCreateNewEpisodesCronFormatted());
    }

    /**
     * Returns the interval between Episodes as defined by the Subreddit's 
     * cron-formatted Episode schedule.
     *
     * @return DateInterval  The interval between Episodes
     */
    public function getEpisodeItervalAsDateInterval()
    {
        $next_creation = $this->getEpisodeScheduleAsCronExpression()->getNextRunDate();
        $after_that = $this->getEpisodeScheduleAsCronExpression()->getNextRunDate($next_creation);
        return $next_creation->diff($after_that);
    }

    /**
     * Returns the interval between Episode genration cycles as defined by the
     * Subreddit's cron-formatted Episode generation schedule.
     *
     * @return DateInterval  The interval between Episode generation cycles.
     */
    public function getCreationIntervalAsDateInterval()
    {
        $next_creation = $this->getCreationScheduleAsCronExpression()->getNextRunDate();
        $after_that = $this->getCreationScheduleAsCronExpression()->getNextRunDate($next_creation);
        return $next_creation->diff($after_that);
    }

    /**
     * Retrieves the release date for the youngest Episode of the Subreddit.
     *
     * @return string  The release date of the youngest Episode. 
     */
    public function getDateOfLastEpisode()
    {
        return SubredditTable::getInstance()->getLastEpisodeReleaseDate($this->getIncremented());
    }

    /**
     * Sets the Subreddit's creation interval to the number of seconds between
     * intervals of the current cron-formatted creation schedule.
     * 
     * It does not save the Subreddit, however.
     */
    public function calculateCreationInterval()
    {
        $creation_schedule = $this->getCreationScheduleAsCronExpression();

        $start = $creation_schedule->getNextRunDate();
        $stop = $creation_schedule->getNextRunDate($start);

        $diff = $start->diff($stop, true);
        $seconds_between = ($diff->y * 365 * 24 * 60 * 60) +
                ($diff->m * 30 * 24 * 60 * 60) +
                ($diff->d * 24 * 60 * 60) +
                ($diff->h * 60 * 60) +
                $diff->s;
        $this->setCreationInterval($seconds_between);
    }

    /**
     * Creates a collection of Episodes with released dates assembled using the
     * Subreddit's Episode schedule between the Subreddit's creation interval.
     *
     * @return array  An array of unsaved Episode objects
     */
    public function collectGeneratedEpisodes()
    {
        ProjectConfiguration::registerCron();

        $episode_schedule = $this->getEpisodeScheduleAsCronExpression();

        $creation_schedule = $this->getCreationScheduleAsCronExpression();

        $last_episode = new DateTime($this->getDateOfLastEpisode());

        $stop_creating = $creation_schedule->getNextRunDate($last_episode);

        $episode_date = $last_episode;

        $new_episodes = array();
        while ($episode_schedule->getNextRunDate($episode_date)->getTimestamp()
        <= $stop_creating->getTimestamp()) {
            $episode_date = $episode_schedule->getNextRunDate($episode_date);

            $episode = new Episode();
            $episode->setSubreddit($this);
            $episode->setReleaseDate($episode_date->format('Y-m-d H:i:s'));
            $new_episodes[] = $episode;
        }


        $this->calculateCreationInterval();
        $this->save();

        return $new_episodes;
    }

}
