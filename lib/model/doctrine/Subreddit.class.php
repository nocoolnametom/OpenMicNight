<?php

/**
 * Subreddit
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    OpenMicNight
 * @subpackage model
 * @author     Tom Doggett
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class Subreddit extends BaseSubreddit
{

    /**
     * Returns the Subreddit name
     *
     * @return string  The object formatted as a string
     */
    public function __toString()
    {
        return $this->getName();
    }

    public function setIncremented($id)
    {
        $this->_id = array($id);
        $this->set('id', $id, false);
        $this->_lastModified = array();
    }

    public function save(Doctrine_Connection $conn = null)
    {
        if ($this->isNew() || (in_array('name', $this->_modified) && $this->_get('name'))) {
            if (!$this->getBucketName() || strlen($this->getBucketName()) == 0) {
                $bucket_name = $this->createAmazonBucketName(
                        ProjectConfiguration::getAmazonBucketPrefix() . $this->_get('name'));
                $this->setBucketName($bucket_name);
            }
        }
        parent::save($conn);
    }

    public function createAmazonBucketName($name)
    {
        ProjectConfiguration::registerAws();
        $s3 = new AmazonS3();
        if (!$s3->if_bucket_exists($name)) {
            $s3->create_bucket($name, AmazonS3::REGION_US_E1,
                               AmazonS3::ACL_AUTH_READ);
            $exists = $s3->if_bucket_exists($name);
            $attempts = 0;
            while (!$exists && $attempts < 10) {
                // Not yet? Sleep for 1 second, then check again
                sleep(1);
                $exists = $s3->if_bucket_exists($name);
                $attempts++;
            }
            return $name;
        }
        $response = $s3->get_bucket_policy($name);
        if (in_array($response->status, array(403, 405)))
            return $this->createAmazonBucketName($name . rand(0, 1000));
    }

    public function deleteAmazonBucket($name)
    {
        ProjectConfiguration::registerAws();
        $s3 = new AmazonS3();
        if ($s3->if_bucket_exists($name)) {
            return $s3->delete_bucket($name, true);
        }
    }

    public function delete(Doctrine_Connection $conn = null)
    {
        $bucket_name = $this->getBucketName();
        parent::delete($conn);
        if ($bucket_name) {
            $this->deleteAmazonBucket($bucket_name);
        }
    }

    /**
     * Returns the Episode schedule as a CronExpression.
     * 
     * @see Cron\CronExpression::factory
     *
     * @return Cron\CronExpression The Episode schedule
     */
    public function getEpisodeScheduleAsCronExpression()
    {
        ProjectConfiguration::registerCron();
        return Cron\CronExpression::factory(parent::getEpisodeScheduleCronFormatted());
    }

    /**
     * Returns the creation schedule as a CronExpression.
     * 
     * @see Cron\CronExpression::factory
     *
     * @return Cron\CronExpression The creation schedule
     */
    public function getCreationScheduleAsCronExpression()
    {
        ProjectConfiguration::registerCron();
        return Cron\CronExpression::factory(parent::getCreateNewEpisodesCronFormatted());
    }

    /**
     * Returns the interval between Episodes as defined by the Subreddit's 
     * cron-formatted Episode schedule.
     *
     * @return DateInterval  The interval between Episodes
     */
    public function getEpisodeItervalAsDateInterval()
    {
        $next_creation = $this->getEpisodeScheduleAsCronExpression()->getNextRunDate();
        $after_that = $this->getEpisodeScheduleAsCronExpression()->getNextRunDate($next_creation);
        return $next_creation->diff($after_that);
    }

    /**
     * Returns the interval between Episode genration cycles as defined by the
     * Subreddit's cron-formatted Episode generation schedule.
     *
     * @return DateInterval  The interval between Episode generation cycles.
     */
    public function getCreationIntervalAsDateInterval()
    {
        $next_creation = $this->getCreationScheduleAsCronExpression()->getNextRunDate();
        $after_that = $this->getCreationScheduleAsCronExpression()->getNextRunDate($next_creation);
        return $next_creation->diff($after_that);
    }

    /**
     * Retrieves the release date for the youngest Episode of the Subreddit.
     *
     * @return string  The release date of the youngest Episode. 
     */
    public function getDateOfLastEpisode()
    {
        return SubredditTable::getInstance()->getLastEpisodeReleaseDate($this->getIncremented());
    }

    /**
     * Sets the Subreddit's creation interval to the number of seconds between
     * intervals of the current cron-formatted creation schedule.
     * 
     * It does not save the Subreddit, however.
     */
    public function calculateCreationInterval()
    {
        $creation_schedule = $this->getCreationScheduleAsCronExpression();

        $start = $creation_schedule->getNextRunDate();
        $stop = $creation_schedule->getNextRunDate($start);

        $diff = $start->diff($stop, true);
        $seconds_between = ($diff->y * 365 * 24 * 60 * 60) +
                ($diff->m * 30 * 24 * 60 * 60) +
                ($diff->d * 24 * 60 * 60) +
                ($diff->h * 60 * 60) +
                $diff->s;
        $this->setCreationInterval($seconds_between);
    }

    /**
     * Creates a collection of Episodes with released dates assembled using the
     * Subreddit's Episode schedule between the Subreddit's creation interval.
     *
     * @return array  An array of unsaved Episode objects
     */
    public function collectGeneratedEpisodes()
    {
        ProjectConfiguration::registerCron();
        
        $this->calculateCreationInterval();

        $episode_schedule = $this->getEpisodeScheduleAsCronExpression();

        $creation_schedule = $this->getCreationScheduleAsCronExpression();
        
        $seconds = $this->getCreationInterval();

        $last_episode = new DateTime(date('R', $this->getDateOfLastEpisode())); // Jan 31 2011

        if ($last_episode->getTimestamp() <= time())
            $last_episode = new DateTime();

        $stop_creating = $creation_schedule->getNextRunDate($last_episode); // 01 Feb 2011
        while((time() + $seconds) > $stop_creating->format('U') ) {
            $stop_creating = $creation_schedule->getNextRunDate($stop_creating);  // Push it out one segment further
        }

        $episode_date = $last_episode;
        
        $new_episodes = array();
        while ($episode_schedule->getNextRunDate($episode_date)->getTimestamp()
        <= $stop_creating->getTimestamp()) {
            $episode_date = $episode_schedule->getNextRunDate($episode_date);

            $episode = new Episode();
            $episode->setSubreddit($this);
            $episode->setReleaseDate($episode_date->format('Y-m-d H:i:s'));
            $new_episodes[] = $episode;
        }

        $this->save();

        return $new_episodes;
    }

    public function getDeadlineRules()
    {
        $deadlines = $this->getDeadlines();

        $deadline_rules = array();

        foreach ($deadlines as $deadline) {
            $deadline_rules[(int) $deadline->getAuthorTypeId()] = $deadline->getSeconds();
        }

        return $deadline_rules;
    }

    public function getFirstDeadlineId()
    {
        $deadline_rules = $this->getDeadlineRules();

        $longest = 0;
        $longest_id = null;
        foreach ($deadline_rules as $id => $seconds) {
            if ($seconds > $longest) {
                $longest = $seconds;
                $longest_id = $id;
            }
        }
        return $longest_id;
    }

    public function advanceEpisodeAssignments()
    {
        $deadline_rules = $this->getDeadlineRules();

        /* Before beginning the process of moving Episodes to new Assignments, 
         * we need to assign Episodes to the first Deadline assignment if they
         * haven't yet been so assigned.
         */
        $longest_id = $this->getFirstDeadlineId();

        $sql = "
SELECT episode_assignment.*
FROM episode_assignment
JOIN episode ON episode.id = episode_assignment.episode_id
WHERE episode.release_date >= NOW()
AND episode.is_approved <> 1
AND episode.subreddit_id = 1
AND episode_assignment.missed_deadline <> 1
AND episode.sf_guard_user_id IS NULL
AND episode_assignment.author_type_id = $longest_id;
        ";
        $query = Doctrine_Query::create()
                ->from('EpisodeAssignment ea')
                ->leftJoin('ea.Episode e')
                ->where('e.release_date >= ?', date('Y-m-d H:i:s'))
                ->andWhere('e.is_approved <> 1')
                ->andWhere('e.subreddit_id = ?', $this->getIncremented())
                ->andWhere('ea.missed_deadline <> 1')
                ->andWhere('e.sf_guard_user_id IS NULL')
                ->andWhere('ea.author_type_id = ?', $longest_id);
        $to_be_assigned = $query->execute();

        foreach ($to_be_assigned as $assignment) {
            /** @var $assignment EpisodeAssignment */
            $episode = $assignment->getEpisode();
            $episode->setSfGuardUserId($assignment->getSfGuardUserId());
            $episode->save();

            $release_date = $episode->getReleaseDate('U');
            $seconds = DeadlineTable::getInstance()->getSecondsByAuthorAndSubreddit($longest_id,
                                                                                    $episode->getSubredditId());
            $deadline = $release_date - $seconds;

            // Send an email to that user telling them their EpisodeAssignment is now valid
            $this->sendEmail($assignment->getSfGuardUserId(),
                             $episode->getIncremented(), $deadline);
        }


        /* We now have an array that shows how many seconds a givn AuthorType is
         * allowed before their Deadline passes for the Subreddit.  Now we need
         * to find all of the EpisodeAssignments attached to future unapproved
         * Episodes that have passed their deadlines and are not so marked.
         */
        $sql = "
SELECT episode_assignment.*
FROM episode_assignment
JOIN episode ON episode.id = episode_assignment.episode_id
WHERE episode.release_date >= NOW()
AND episode.is_approved <> 1
AND episode.subreddit_id = 1
AND episode_assignment.missed_deadline <> 1
AND (
  (episode_assignment.author_type_id = 1 AND NOW() >= (episode.release_date - 86400))
  OR (episode_assignment.author_type_id = 2 AND NOW() >= (episode.release_date - 172800))
  OR (episode_assignment.author_type_id = 3 AND NOW() >= (episode.release_date - 259200))
  OR (episode_assignment.author_type_id = 4 AND NOW() >= (episode.release_date - 0))
)";
        $rules_query = '';
        $first = true;
        foreach ($deadline_rules as $id => $seconds) {
            $rules_query .= ($first ? '' : ' OR ') . "(ea.author_type_id = $id AND ('" . date('Y-m-d H:i:s',
                                                                                              time() + $seconds) . "' >= e.release_date))";
            $first = false;
        }
        $query = Doctrine_Query::create()
                ->from('EpisodeAssignment ea')
                ->leftJoin('ea.Episode e')
                ->where('e.release_date >= ?', date('Y-m-d H:i:s'))
                ->andWhere('e.is_approved <> 1')
                ->andWhere('e.subreddit_id = ?', $this->getIncremented())
                ->andWhere('ea.missed_deadline <> 1')
                ->andWhere("($rules_query)");
        $assignments = $query->execute();

        // We now have all assignments that are beyond their deadlines
        foreach ($assignments as $assignment) {
            /* @var $assignment EpisodeAssignment */

            // Set the EpisodeAssignment that it missed its deadline.
            $assignment->setMissedDeadline(true);
            $episode = $assignment->getEpisode();

            $next_assignment = null;

            if ($episode->getSfGuardUserId() == $assignment->getSfGuardUserId()) {
                // Remove the current user from the Episode.           
                $episode->setSfGuardUserId(null);

                // Clean up the Episode for the new user.
                $audio_file = $episode->getAudioFile();
                $nice_filename = $episode->getNiceFilename();
                $graphic_file = $episode->getGraphicFile();
                $episode->setAudioFile(null);
                $episode->setNiceFilename(null);
                $episode->setGraphicFile(null);
                $episode->setIsNsfw(false);
                $episode->setTitle(null);
                $episode->setDescription(null);
                $episode->setIsSubmitted(false);
                $episode->setSubmittedAt(null);
                $episode->setFileIsRemote(null);
                $episode->setRemoteUrl(null);
                $episode->setRedditPostUrl(null);

                // Find the next EpisodeAssignment in line for the Episode
                $next_assignment = $episode->getCurrentEpisodeAssignmentByDeadline();

                // Set the user for the Episode to the new user
                $episode->setSfGuardUserId($next_assignment->getSfGuardUserId());
            }
            // Save everything
            $episode->save();
            $assignment->save();

            if (!is_null($next_assignment) && $next_assignment instanceof EpisodeAssignment) {
                // We assemble the deadline date for the EpisodeAssignment.
                $release_date = $episode->getReleaseDate('U');
                $seconds = DeadlineTable::getInstance()->getSecondsByAuthorAndSubreddit($next_assignment->getAuthorTypeId(),
                                                                                        $episode->getSubredditId());
                $deadline = $release_date - $seconds;

                // Send an email to that user telling them their EpisodeAssignment is now valid
                $this->sendEmail($next_assignment->getSfGuardUserId(),
                                 $episode->getIncremented(), $deadline);
            }
        }
    }

    public function sendEmail($user_id, $episode_id, $deadline)
    {
        // Send an email to that user telling them their EpisodeAssignment is now valid
        ProjectConfiguration::registerZend();

        $mail = new Zend_Mail();
        $mail->addHeader('X-MailGenerator',
                         ProjectConfiguration::getApplicationName());
        $parameters = array(
            'user_id' => $user_id,
            'episode_id' => $episode_id,
            'deadline' => $deadline,
        );
        $user = sfGuardUserTable::getInstance()->find($user_id);

        $prefer_html = $user->getPreferHtml();
        $address = $user->getEmailAddress();
        $name = ($user->getPreferredName() ?
                        $user->getPreferredName() : $user->getFullName());

        $email = EmailTable::getInstance()->getFirstByEmailTypeAndLanguage('NewlyOpenedEpisode',
                                                                           $user->getPreferredLanguage());

        $subject = $email->generateSubject($parameters);
        $body = $email->generateBodyText($parameters, $prefer_html);

        $mail->setBodyText($body);

        $mail->setFrom(sfConfig::get('app_email_address',
                                     'donotreply@' . ProjectConfiguration::getApplicationName()),
                                     sfconfig::get('app_email_name',
                                                   ProjectConfiguration::getApplicationName() . 'Team'));
        $mail->addTo($address, $name);
        $mail->setSubject($subject);
        if (sfConfig::get('sf_environment') == 'prod') {
            $mail->send();
        } else {
            //throw new sfException('Mail sent: ' . $mail->getBodyText()->getRawContent());
            if (sfConfig::get('sf_logging_enabled')) {
                sfContext::getInstance()->getLogger()->info('Mail sent: ' . $mail->getBodyText()->getRawContent());
            }
        }
        $user->addLoginMessage('You have an episode that you can work with!');
    }
}
