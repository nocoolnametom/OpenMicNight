<?php

/**
 * Subreddit
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    OpenMicNight
 * @subpackage model
 * @author     Tom Doggett
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class Subreddit extends BaseSubreddit
{

    /**
     * Returns the Subreddit name
     *
     * @return string  The object formatted as a string
     */
    public function __toString()
    {
        return $this->getName();
    }

    public function setName($name)
    {
        $this->_set('name', $name);
        if (!$this->getBucketName() || strlen($this->getBucketName()) == 0) {
            $bucket_name = $this->createAmazonBucketName(
                    ProjectConfiguration::getAmazonBucketPrefix() . $name);
            $this->setBucketName($bucket_name);
        }
    }

    public function createAmazonBucketName($name)
    {
        ProjectConfiguration::registerAws();
        $s3 = new AmazonS3();
        if (!$s3->if_bucket_exists($name)) {
            $s3->create_bucket($name, AmazonS3::REGION_US_E1, AmazonS3::ACL_PUBLIC);
            $exists = $s3->if_bucket_exists($name);
            while (!$exists) {
                // Not yet? Sleep for 1 second, then check again
                sleep(1);
                $exists = $s3->if_bucket_exists($name);
            }
            return $name;
        }
        $response = $s3->get_bucket_policy($name);
        if (in_array($response->status, array(403, 405)))
            return $this->createAmazonBucketName($name . rand(0, 1000));
    }

    public function deleteAmazonBucket($name)
    {
        ProjectConfiguration::registerAws();
        $s3 = new AmazonS3();
        if ($s3->if_bucket_exists($name)) {
            return $s3->delete_bucket($name, true);
        }
    }

    public function delete(Doctrine_Connection $conn = null)
    {
        $bucket_name = $this->getBucketName();
        parent::delete($conn);
        if ($bucket_name) {
            $this->deleteAmazonBucket($bucket_name);
        }
    }

    /**
     * Returns the Episode schedule as a CronExpression.
     * 
     * @see Cron\CronExpression::factory
     *
     * @return Cron\CronExpression The Episode schedule
     */
    public function getEpisodeScheduleAsCronExpression()
    {
        ProjectConfiguration::registerCron();
        return Cron\CronExpression::factory(parent::getEpisodeScheduleCronFormatted());
    }

    /**
     * Returns the creation schedule as a CronExpression.
     * 
     * @see Cron\CronExpression::factory
     *
     * @return Cron\CronExpression The creation schedule
     */
    public function getCreationScheduleAsCronExpression()
    {
        ProjectConfiguration::registerCron();
        return Cron\CronExpression::factory(parent::getCreateNewEpisodesCronFormatted());
    }

    /**
     * Returns the interval between Episodes as defined by the Subreddit's 
     * cron-formatted Episode schedule.
     *
     * @return DateInterval  The interval between Episodes
     */
    public function getEpisodeItervalAsDateInterval()
    {
        $next_creation = $this->getEpisodeScheduleAsCronExpression()->getNextRunDate();
        $after_that = $this->getEpisodeScheduleAsCronExpression()->getNextRunDate($next_creation);
        return $next_creation->diff($after_that);
    }

    /**
     * Returns the interval between Episode genration cycles as defined by the
     * Subreddit's cron-formatted Episode generation schedule.
     *
     * @return DateInterval  The interval between Episode generation cycles.
     */
    public function getCreationIntervalAsDateInterval()
    {
        $next_creation = $this->getCreationScheduleAsCronExpression()->getNextRunDate();
        $after_that = $this->getCreationScheduleAsCronExpression()->getNextRunDate($next_creation);
        return $next_creation->diff($after_that);
    }

    /**
     * Retrieves the release date for the youngest Episode of the Subreddit.
     *
     * @return string  The release date of the youngest Episode. 
     */
    public function getDateOfLastEpisode()
    {
        return SubredditTable::getInstance()->getLastEpisodeReleaseDate($this->getIncremented());
    }

    /**
     * Sets the Subreddit's creation interval to the number of seconds between
     * intervals of the current cron-formatted creation schedule.
     * 
     * It does not save the Subreddit, however.
     */
    public function calculateCreationInterval()
    {
        $creation_schedule = $this->getCreationScheduleAsCronExpression();

        $start = $creation_schedule->getNextRunDate();
        $stop = $creation_schedule->getNextRunDate($start);

        $diff = $start->diff($stop, true);
        $seconds_between = ($diff->y * 365 * 24 * 60 * 60) +
                ($diff->m * 30 * 24 * 60 * 60) +
                ($diff->d * 24 * 60 * 60) +
                ($diff->h * 60 * 60) +
                $diff->s;
        $this->setCreationInterval($seconds_between);
    }

    /**
     * Creates a collection of Episodes with released dates assembled using the
     * Subreddit's Episode schedule between the Subreddit's creation interval.
     *
     * @return array  An array of unsaved Episode objects
     */
    public function collectGeneratedEpisodes()
    {
        ProjectConfiguration::registerCron();

        $episode_schedule = $this->getEpisodeScheduleAsCronExpression();

        $creation_schedule = $this->getCreationScheduleAsCronExpression();

        $last_episode = new DateTime($this->getDateOfLastEpisode()); // Jan 31 2011

        if ($last_episode->getTimestamp() < time())
            $last_episode = new DateTime();

        $stop_creating = $creation_schedule->getNextRunDate($last_episode); // 01 Feb 2011

        $episode_date = $last_episode;

        $new_episodes = array();
        while ($episode_schedule->getNextRunDate($episode_date)->getTimestamp()
        <= $stop_creating->getTimestamp()) {
            $episode_date = $episode_schedule->getNextRunDate($episode_date);

            $episode = new Episode();
            $episode->setSubreddit($this);
            $episode->setReleaseDate($episode_date->format('Y-m-d H:i:s'));
            $new_episodes[] = $episode;
        }


        $this->calculateCreationInterval();
        $this->save();

        return $new_episodes;
    }

    public function getDeadlineRules()
    {
        $deadlines = $this->getDeadlines();

        $deadline_rules = array();

        foreach ($deadlines as $deadline) {
            $deadline_rules[(int) $deadline->getAuthorTypeId()] = $deadline->getSeconds();
        }

        return $deadline_rules;
    }

    public function advanceEpisodeAssignments()
    {
        $deadline_rules = $this->getDeadlineRules();

        /* We now have an array that shows how many seconds a givn AuthorType is
         * allowed before their Deadline passes for the Subreddit.  Now we need
         * to find all of the EpisodeAssignments attached to future unapproved
         * Episodes that havge passed their deadlines and are not so marked.
         */
        $sql = "
SELECT episode_assignment.*
FROM episode_assignment
JOIN episode ON episode.id = episode_assignment.episode_id
WHERE episode.release_date >= NOW()
AND episode.is_approved <> 1
AND episode.subreddit_id = 1
AND episode_assignment.missed_deadline <> 1
AND (
  (episode_assignment.author_type_id = 1 AND NOW() >= (episode.release_date - 86400))
  OR (episode_assignment.author_type_id = 2 AND NOW() >= (episode.release_date - 172800))
  OR (episode_assignment.author_type_id = 3 AND NOW() >= (episode.release_date - 259200))
  OR (episode_assignment.author_type_id = 4 AND NOW() >= (episode.release_date - 0))
)";
        $rules_query = '';
        $first = true;
        foreach ($deadline_rules as $id => $seconds) {
            $rules_query .= ($first ? '' : ' OR ') . "(ea.author_type_id = $id AND ('" . date('Y-m-d H:i:s', time() + $seconds) . "' >= e.release_date))";
            $first = false;
        }
        $query = Doctrine_Query::create()
                ->from('EpisodeAssignment ea')
                ->leftJoin('ea.Episode e')
                ->where('e.release_date >= ?', date('Y-m-d H:i:s'))
                ->andWhere('e.is_approved <> 1')
                ->andWhere('e.subreddit_id = ?', $this->getIncremented())
                ->andWhere('ea.missed_deadline <> 1')
                ->andWhere("($rules_query)");
        $assignments = $query->execute();

        // We now have all assignments that are beyond their deadlines
        foreach ($assignments as $assignment) {
            /* @var $assignment EpisodeAssignment */

            // Set the EpisodeAssignment that it missed its deadline.
            $assignment->setMissedDeadline(true);
            $episode = $assignment->getEpisode();

            $next_assignment = null;

            if ($episode->getSfGuardUserId() == $assignment->getSfGuardUserId()) {
                // Remove the current user from the Episode.           
                $episode->setSfGuardUserId(null);

                // Clean up the Episode for the new user.
                $audio_file = $episode->getAudioFile();
                $nice_filename = $episode->getNiceFilename();
                $graphic_file = $episode->getGraphicFile();
                $episode->setAudioFile(null);
                $episode->setNiceFilename(null);
                $episode->setGraphicFile(null);
                $episode->setIsNsfw(false);
                $episode->setTitle(null);
                $episode->setDescription(null);
                $episode->setIsSubmitted(false);
                $episode->setSubmittedAt(null);
                $episode->setFileIsRemote(null);
                $episode->setRemoteUrl(null);
                $episode->setRedditPostUrl(null);

                // Find the next EpisodeAssignment in line for the Episode
                $next_assignment = $episode->getCurrentEpisodeAssignmentByDeadline();

                // Set the user for the Episode to the new user
                $episode->setSfGuardUserId($next_assignment->getSfGuardUserId());
            }
            // Save everything
            $episode->save();
            $assignment->save();

            if (!is_null($next_assignment) && $next_assignment instanceof EpisodeAssignment) {
                // We assemble the deadline date for the EpisodeAssignment.
                $release_date = $episode->getReleaseDate('U');
                $seconds = DeadlineTable::getInstance()->getSecondsByAuthorAndSubreddit($next_assignment->getAuthorTypeId(), $episode->getSubredditId());
                $deadline = $release_date - $seconds;

                // Send an email to that user telling them their EpisodeAssignment is now valid
                ProjectConfiguration::registerZend();

                $mail = new Zend_Mail();
                $mail->addHeader('X-MailGenerator', ProjectConfiguration::getApplicationName());
                $parameters = array(
                    'user_id' => $next_assignment->getSfGuardUserId(),
                    'episode_id' => $episode->getIncremented(),
                    'deadline' => $deadline,
                );
                $user = $next_assignment->getSfGuardUser();

                $prefer_html = $user->getPreferHtml();
                $address = $user->getEmailAddress();
                $name = ($user->getPreferredName() ?
                                $user->getPreferredName() : $user->getFullName());

                $email = EmailTable::getInstance()->getFirstByEmailTypeAndLanguage('NewlyOpenedEpisode', $user->getPreferredLanguage());

                $subject = $email->generateSubject($parameters);
                $body = $email->generateBodyText($parameters, $prefer_html);

                $mail->setBodyText($body);

                $mail->setFrom(sfConfig::get('app_email_address', 'donotreply@' . ProjectConfiguration::getApplicationName()), sfconfig::get('app_email_name', ProjectConfiguration::getApplicationName() . 'Team'));
                $mail->addTo($address, $name);
                $mail->setSubject($subject);
                if (sfConfig::get('sf_environment') == 'prod') {
                    $mail->send();
                } else {
                    throw new sfException('Mail sent: ' . $mail->getBodyText()->getRawContent());
                }
            }
        }
    }

}
