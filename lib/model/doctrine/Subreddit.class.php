<?php

/**
 * Subreddit
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    OpenMicNight
 * @subpackage model
 * @author     Tom Doggett
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class Subreddit extends BaseSubreddit
{

    public function __toString()
    {
        return $this->getName();
    }

    public function getEpisodeScheduleAsCronExpression()
    {
        ProjectConfiguration::registerCron();
        return Cron\CronExpression::factory(parent::getEpisodeScheduleCronFormatted());
    }

    public function getCreationScheduleAsCronExpression()
    {
        ProjectConfiguration::registerCron();
        return Cron\CronExpression::factory(parent::getCreateNewEpisodesCronFormatted());
    }

    public function getEpisodeItervalAsDateInterval()
    {
        $next_creation = $this->getEpisodeScheduleAsCronExpression()->getNextRunDate();
        $after_that = $this->getEpisodeScheduleAsCronExpression()->getNextRunDate($next_creation);
        return $next_creation->diff($after_that);
    }

    public function getCreationIntervalAsDateInterval()
    {
        $next_creation = $this->getCreationScheduleAsCronExpression()->getNextRunDate();
        $after_that = $this->getCreationScheduleAsCronExpression()->getNextRunDate($next_creation);
        return $next_creation->diff($after_that);
    }

    public function getDateOfLastEpisode()
    {
        return SubredditTable::getInstance()->getLastEpisodeReleaseDate($this->getIncremented());
    }

    public function calculateCreationInterval()
    {
        $creation_schedule = $this->getCreationScheduleAsCronExpression();

        $start = $creation_schedule->getNextRunDate();
        $stop = $creation_schedule->getNextRunDate($start);

        $diff = $start->diff($stop, true);
        $seconds_between = ($diff->y * 365 * 24 * 60 * 60) +
                ($diff->m * 30 * 24 * 60 * 60) +
                ($diff->d * 24 * 60 * 60) +
                ($diff->h * 60 * 60) +
                $diff->s;
        $this->setCreationInterval($seconds_between);
    }

    public function collectGeneratedEpisodes()
    {
        ProjectConfiguration::registerCron();

        $episode_schedule = $this->getEpisodeScheduleAsCronExpression();

        $creation_schedule = $this->getCreationScheduleAsCronExpression();

        $last_episode = new DateTime($this->getDateOfLastEpisode());

        $stop_creating = $creation_schedule->getNextRunDate($last_episode);

        $episode_date = $last_episode;

        $new_episodes = array();
        while ($episode_schedule->getNextRunDate($episode_date)->getTimestamp()
        <= $stop_creating->getTimestamp()) {
            $episode_date = $episode_schedule->getNextRunDate($episode_date);

            $episode = new Episode();
            $episode->setSubreddit($this);
            $episode->setReleaseDate($episode_date->format('Y-m-d H:i:s'));
            $new_episodes[] = $episode;
        }


        $this->calculateCreationInterval();
        $this->save();

        return $new_episodes;
    }

}
